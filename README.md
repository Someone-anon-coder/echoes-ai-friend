# Echoes AI Friend

**Version:** 1.0.0 (as per current file structure)
**Last Updated:** (Current Date)

## 1. Project Overview

Echoes AI Friend is an interactive chat application designed to simulate conversations with AI-driven personas. Users can select different scenarios and AI genders, leading to unique AI characters with distinct personalities, hobbies, and even secrets. The core gameplay revolves around building a relationship with the AI, managed through a scoring system influenced by user interactions. The application also features a credit system, differentiating between free and premium users, and offers mock purchases for additional credits.

The primary goal is to provide an engaging and evolving conversational experience, where the AI remembers past interactions (via summaries) and adapts its behavior based on the established relationship.

## 2. Core Features

*   **Dynamic AI Persona Generation:** AI personas are generated by the Gemini API based on user-selected scenarios and genders. Each persona has a unique name, hobbies, personality traits, a secret, and an initial system message setting the scene.
*   **Interactive Chatting:** Users can send messages to the AI, which responds in character. The AI can express actions (`<action>`) and describe visual details (`<visual>`) within its messages.
*   **Relationship System:** A relationship score (0-100) tracks the user's bond with the AI. This score is updated based on sentiment analysis of user messages (via Gemini API) and influences the AI's behavior and dialogue. Different score ranges correspond to relationship levels (Stranger, Acquaintance, Friend, etc.).
*   **Credit Management:**
    *   Users have a credit balance, consumed per message sent.
    *   Free and premium users have different initial credit amounts and daily credit refresh rates.
    *   A "Shop" allows users to (mock) purchase credit packages.
    *   Users can (mock) upgrade to a "Premium" account via their profile.
*   **Onboarding Process:**
    *   **Scenario Selection:** Users choose from a list of free and premium scenarios that define the initial context of the interaction.
    *   **Gender Selection:** Users choose the AI's gender, which influences persona generation.
*   **State Persistence:** User progress (user state, game state including chat history and relationship score) is saved to the browser's Local Storage, allowing users to resume their sessions.
*   **Login/Logout:** A mock login system using a username (can be an email) and password. User-specific data is loaded upon login.
*   **AI Busy State:** The AI has a chance to become "busy" for a random duration, adding a layer of realism.
*   **Conversation Summarization:** To maintain long-term memory, longer conversations are periodically summarized by the Gemini API.
*   **Error Handling:** Basic display of error messages for API failures or insufficient credits.
*   **Responsive UI:** The application is designed to be responsive across different screen sizes using Tailwind CSS.
*   **Dark Mode Support:** UI elements adapt to system dark mode preferences.

## 3. Technology Stack

*   **Frontend Library:** React 19 (`react`, `react-dom`)
*   **Language:** TypeScript
*   **Styling:** Tailwind CSS (via CDN)
*   **AI Model Integration:** Google Gemini API (`@google/genai`)
    *   Model for text generation and analysis: `gemini-2.5-flash-preview-04-17`
*   **Build/Module System:** ES Modules (ESM) with import maps in `index.html`.
*   **HTTP Client:** Implicitly, the `@google/genai` SDK handles API requests.

## 4. Project Structure

The project consists of several key files and directories:

```
.
├── README.md                 # This file
├── index.html                # Main HTML entry point, loads React app and Tailwind CSS
├── index.tsx                 # React application root, mounts App component
├── metadata.json             # Application metadata (name, description, permissions)
├── types.ts                  # TypeScript type definitions and enums
├── constants.ts              # Application-wide constants
├── App.tsx                   # Main application component, handles state management and routing
│
├── components/               # Directory for UI components
│   ├── ChatView.tsx          # Component for the main chat interface
│   ├── GameOverView.tsx      # Component for the "game over" screen (relationship lost)
│   ├── Header.tsx            # Application header (title, credits, navigation)
│   ├── LoadingSpinner.tsx    # Reusable loading animation
│   ├── LoginView.tsx         # Component for user login and mock signup
│   ├── MessageDisplay.tsx    # Component for rendering individual chat messages
│   ├── OnboardingView.tsx    # Component for scenario and AI gender selection
│   ├── PaymentModal.tsx      # Modal for mock payment processing
│   ├── ProfileView.tsx       # Component for user profile (status, credits, premium toggle)
│   └── ShopView.tsx          # Component for purchasing credit packages
│
├── services/                 # Directory for external service integrations
│   └── geminiService.ts      # Functions for interacting with the Google Gemini API
│
└── utils/                    # Directory for utility functions
    └── localStorageHelper.ts # Helper functions for saving/loading state to Local Storage
```

### 4.1 Root Files

*   **`index.html`**:
    *   The main entry point for the web application.
    *   Sets up the basic HTML structure, viewport, and title.
    *   Includes Tailwind CSS via CDN.
    *   Defines an import map for ES module resolution (React, `@google/genai`).
    *   Contains the root `div` (`<div id="root"></div>`) where the React application is mounted.
    *   Loads the main TypeScript module (`index.tsx`).
*   **`index.tsx`**:
    *   The entry point for the React application.
    *   Imports React, ReactDOM, and the main `App` component.
    *   Renders the `App` component into the root DOM element.
*   **`metadata.json`**:
    *   Contains metadata about the application, potentially for a hosting platform.
    *   Includes `name`, `description`, `requestFramePermissions` (currently empty), and `prompt` (currently empty).
*   **`types.ts`**:
    *   Defines all custom TypeScript types, enums, and interfaces used throughout the application.
    *   Key types include: `AppScreen` (enum for navigation), `Scenario`, `AIGender` (enum), `AIPersona`, `UserState`, `ChatMessage`, `RelationshipLevel` (enum), `GameState`, `AppContextProps`.
*   **`constants.ts`**:
    *   Stores global constants used in the application.
    *   Includes `GEMINI_API_MODEL_TEXT`, lists of `FREE_SCENARIOS` and `PREMIUM_SCENARIOS`, relationship score thresholds, credit values, AI busy parameters, etc.
    *   Provides utility functions like `getRelationshipLevel`.
*   **`App.tsx`**:
    *   The core component of the application, orchestrating all other views and logic.
    *   Manages global application state: `appScreen`, `userState`, `gameState`, `isLoading`, `errorMessage`, payment modal state.
    *   Handles navigation between different screens/views (`AppScreen`).
    *   Contains logic for:
        *   User login and logout.
        *   Daily credit refresh.
        *   Scenario and gender selection.
        *   AI persona generation.
        *   Sending and receiving chat messages.
        *   Updating relationship scores.
        *   Conversation summarization.
        *   Handling AI busy states.
        *   Resetting scenarios.
        *   Toggling premium status.
        *   Mock credit purchases.
    *   Interacts with `localStorageHelper` to save and load user/game state.
    *   Interacts with `geminiService` for AI-related functionalities.
    *   Renders the `Header` and the current screen's component.

### 4.2 `components/` Directory

This directory houses all the React functional components responsible for the UI.

*   **`ChatView.tsx`**:
    *   Displays the chat interface between the user and the AI.
    *   Renders `MessageDisplay` for each message in the `chatHistory`.
    *   Includes an input field for the user to type messages and a send button.
    *   Handles sending messages via the `onSendMessage` prop.
    *   Shows a loading spinner when waiting for an AI response.
    *   Displays the initial system message related to the scenario.
    *   Provides a button to insert `<action>` tags into the input.
*   **`GameOverView.tsx`**:
    *   Displayed when the relationship score drops to the minimum, indicating the "connection is lost."
    *   Shows a message and an option to reset and start a new scenario.
*   **`Header.tsx`**:
    *   The main application header.
    *   Displays the application title ("Echoes").
    *   Shows user credits and premium status (if applicable).
    *   Provides navigation buttons to "Profile" and "Shop".
    *   Includes a "Reset Scenario" button (on chat/game over screens) and a "Logout" button.
*   **`LoadingSpinner.tsx`**:
    *   A simple, reusable component that displays an animated loading spinner. Used to indicate background processes or data fetching.
*   **`LoginView.tsx`**:
    *   Provides a form for users to "log in" or "sign up" (mock).
    *   Takes username and password inputs.
    *   Calls `onLogin` prop upon submission.
*   **`MessageDisplay.tsx`**:
    *   Renders a single chat message.
    *   Styles messages differently based on the sender (user, AI, or system).
    *   Parses and styles special tags within AI messages:
        *   `<action>...</action>`: Italicized text for AI actions.
        *   `<visual>...</visual>`: Italicized text with a border for visual descriptions.
*   **`OnboardingView.tsx`**:
    *   Manages the initial setup steps for a new chat.
    *   Displays either scenario selection or AI gender selection based on the `currentStep` prop.
    *   Handles user selections and calls `onScenarioSelect` or `onGenderSelect`.
    *   Disables premium scenarios for non-premium users.
*   **`PaymentModal.tsx`**:
    *   A modal dialog for simulating a payment process.
    *   Appears when a user tries to buy a credit package from the `ShopView`.
    *   Includes mock input fields for card number, expiry, and CVV.
    *   Simulates processing and calls `onConfirmPurchase` on "success".
*   **`ProfileView.tsx`**:
    *   Displays user profile information: current status (Free/Premium) and credit balance.
    *   Allows users to toggle their premium status (mock functionality).
    *   Provides a "Back" button to return to the previous screen.
*   **`ShopView.tsx`**:
    *   Displays available credit packages for purchase (mock).
    *   Shows package name, credits offered, and a brief description.
    *   Initiates the mock purchase process by calling `onInitiatePurchase`, which opens the `PaymentModal`.
    *   Provides a "Back" button.

### 4.3 `services/` Directory

*   **`geminiService.ts`**:
    *   Handles all interactions with the Google Gemini API.
    *   Initializes the `GoogleGenAI` client using `process.env.API_KEY`.
    *   **`generateAIPersonaService`**: Generates an AI persona (name, hobbies, personality, secret, initial messages) based on a chosen scenario and gender. Expects a JSON response from Gemini.
    *   **`generateAIChatResponseService`**: Generates the AI's chat response to a user's message. Considers the AI's persona, relationship score, conversation summary, and recent chat history.
    *   **`summarizeConversationService`**: Summarizes a segment of the chat history from the AI's perspective to serve as its memory.
    *   **`analyzeSentimentForRelationshipUpdateService`**: Analyzes the user's message to determine how the relationship score should change (positive, negative, or neutral). Expects an integer response.
    *   Includes a helper `parseJsonFromGeminiResponse` to safely parse JSON from Gemini's text output, handling potential markdown fences.

### 4.4 `utils/` Directory

*   **`localStorageHelper.ts`**:
    *   Provides functions to interact with the browser's Local Storage for state persistence.
    *   `saveUserState(userState)`: Saves the `UserState` object.
    *   `loadUserState(userId)`: Loads `UserState` for a given user ID (or a generic key if ID is null).
    *   `saveGameState(gameState, userId)`: Saves the `GameState` object associated with a user ID.
    *   `loadGameState(userId)`: Loads `GameState` for a given user ID.
    *   `clearUserState(userId)`: Removes `UserState` for a user.
    *   `clearGameState(userId)`: Removes `GameState` for a user.
    *   Uses user-specific keys (e.g., `echoes_userState_guest` or `echoes_userState_userID123`) for storing data, though the current implementation is simplified for mocking.

## 5. Key Concepts and Logic

### 5.1 State Management (`UserState`, `GameState`)

The application's state is primarily managed within the `App.tsx` component using React's `useState` hook.

*   **`UserState`**: Stores information about the logged-in user.
    *   `userId`: A unique identifier for the user (mocked).
    *   `isLoggedIn`: Boolean indicating login status.
    *   `credits`: The user's current credit balance.
    *   `isPremium`: Boolean indicating if the user has a premium account.
    *   `lastLoginDate`: Used to determine if daily credits should be awarded.
*   **`GameState`**: Stores information about the current chat session.
    *   `currentScenario`: The selected `Scenario` object.
    *   `aiPersona`: The generated `AIPersona` object for the current AI.
    *   `relationshipScore`: A number (0-100) representing the user-AI relationship.
    *   `chatHistory`: An array of `ChatMessage` objects, forming the conversation log.
    *   `conversationSummary`: A string accumulating summaries of the conversation for AI memory.

Both states are persisted to Local Storage to allow users to resume sessions.

### 5.2 Navigation (`AppScreen`)

Navigation between different views/screens is controlled by the `appScreen` state variable in `App.tsx`, which is of type `AppScreen` (an enum). Changing this state variable re-renders the appropriate component. Key screens include: `LOGIN`, `ONBOARDING_SCENARIO`, `ONBOARDING_GENDER`, `CHATTING`, `GAME_OVER`, `PROFILE`, `SHOP`.

### 5.3 Gemini API Integration

The `geminiService.ts` module is central to the AI's functionality.
*   **API Key:** The `GoogleGenAI` client is initialized with `process.env.API_KEY`. The application checks for this key's presence and alerts the user if it's missing.
*   **Persona Generation:** `generateAIPersonaService` crafts a detailed prompt for Gemini, asking for a JSON object representing the AI persona.
*   **Chat Responses:** `generateAIChatResponseService` sends the AI's persona details, current relationship status, conversation summary, and recent chat history to Gemini to generate contextually relevant and in-character responses. It instructs the AI to use `<action>` and `<visual>` tags.
*   **Sentiment Analysis:** `analyzeSentimentForRelationshipUpdateService` prompts Gemini to evaluate the user's message and return an integer score change (-2 to +2) for the relationship.
*   **Conversation Summarization:** `summarizeConversationService` prompts Gemini to create concise summaries of chat segments to aid the AI's long-term memory.
*   **JSON Parsing:** A utility `parseJsonFromGeminiResponse` handles extracting JSON data from Gemini's potentially markdown-formatted text responses.
*   **Model Used:** `gemini-2.5-flash-preview-04-17` is consistently used for all text-based tasks.

### 5.4 Credit System

*   Users start with initial credits (`FREE_USER_INITIAL_CREDITS` or `PREMIUM_USER_INITIAL_CREDITS`).
*   Daily credits (`FREE_USER_DAILY_CREDITS` or `PREMIUM_USER_DAILY_CREDITS`) are added upon the first login of a new day.
*   Each message sent by the user costs `CREDITS_PER_TURN` (currently 1).
*   The Shop allows mock purchases of credit packages.
*   Premium status can be toggled in the Profile, affecting daily credit rewards and access to premium scenarios.

### 5.5 Relationship System

*   Starts at `INITIAL_RELATIONSHIP_SCORE`.
*   Score changes based on `analyzeSentimentForRelationshipUpdateService` output.
*   Clamped between `MIN_RELATIONSHIP_SCORE` (0) and `MAX_RELATIONSHIP_SCORE` (100).
*   If the score drops to 0, the `GAME_OVER` screen is shown.
*   The current `RelationshipLevel` (e.g., Acquaintance, Friend) is derived from the score and passed to Gemini to influence AI responses.
*   The AI's secret is intended to be revealed only at high relationship levels.

### 5.6 AI Persona & Interaction

*   AI personas are designed to be unique, with distinct names, hobbies, personalities, and secrets.
*   The `initialSystemMessage` sets the scene for the chosen scenario.
*   The AI might have a `firstAIMessage` if it's meant to speak first.
*   AI responses can include `<action>` (e.g., `<action>smiles</action>`) and `<visual>` (e.g., `<visual>A book lies open on the table</visual>`) tags, which `MessageDisplay.tsx` renders with specific styling.
*   The AI can become "busy" for a period, during which it won't respond directly but a system message will indicate its status.

### 5.7 Local Storage Persistence

The `localStorageHelper.ts` module handles saving and loading `UserState` and `GameState` to the browser's Local Storage. This allows users to close the application and resume their progress later. Data is stored under keys prefixed with `echoes_userState_` and `echoes_gameState_`, potentially with a user ID appended.

## 6. Setup and Prerequisites

*   **Web Browser:** A modern web browser with JavaScript enabled.
*   **Gemini API Key:** The application requires a valid Google Gemini API key. This key **must** be set as an environment variable named `API_KEY`.
    *   The application assumes `process.env.API_KEY` is accessible.
    *   If the key is missing, an alert will be shown, and AI functionalities will fail.
*   **Internet Connection:** Required for fetching Tailwind CSS (if not cached) and for all interactions with the Gemini API.

**Running the Application (Conceptual):**
Since this is a frontend project using ES modules and potentially hosted statically:
1.  Ensure the `API_KEY` environment variable is correctly configured in the environment where the application's JavaScript will execute (e.g., if served by a simple HTTP server or a more complex deployment setup).
2.  Open `index.html` in a web browser. The browser will handle the ES module imports defined in the `script type="importmap"`.

## 7. How it Works (High-Level Flow)

1.  **Initial Load:**
    *   `index.html` is loaded.
    *   `index.tsx` mounts the `App` component.
    *   `App.tsx` attempts to load existing user state. If a logged-in user is found, their session is restored; otherwise, the `LOGIN` screen is shown.
2.  **Login:**
    *   User enters mock credentials in `LoginView`.
    *   `handleSuccessfulLogin` in `App.tsx` loads/initializes `UserState`, awards daily credits if applicable, and loads `GameState` if available.
    *   If no active game, navigates to `ONBOARDING_SCENARIO`. If an active game exists, navigates to `CHATTING`.
3.  **Onboarding:**
    *   User selects a scenario in `OnboardingView`.
    *   User selects an AI gender in `OnboardingView`.
    *   `handleGenderSelect` calls `generateAIPersonaService` to get AI persona details from Gemini.
    *   `GameState` is initialized with the scenario and persona. Navigates to `CHATTING`.
4.  **Chatting:**
    *   `ChatView` displays chat history and input field.
    *   User types a message and sends it.
    *   `handleSendMessage` in `App.tsx` is triggered:
        *   User's credits are debited.
        *   User message is added to `chatHistory`.
        *   `analyzeSentimentForRelationshipUpdateService` is called to adjust `relationshipScore`.
        *   If score drops to 0, navigates to `GAME_OVER`.
        *   Checks if AI is busy. If so, displays a system message.
        *   If AI is available, `generateAIChatResponseService` is called to get AI's reply.
        *   AI's response is added to `chatHistory`.
        *   Periodically, `summarizeConversationService` is called to update `conversationSummary`.
        *   AI might become busy after responding.
        *   `UserState` and `GameState` are updated and saved to Local Storage.
5.  **Profile/Shop:**
    *   User can navigate to `ProfileView` to toggle premium status or `ShopView` to (mock) buy credits.
    *   Changes to `UserState` (credits, premium) are saved.
6.  **Logout/Reset:**
    *   User can log out (clears state, navigates to `LOGIN`) or reset scenario (clears `GameState`, navigates to `ONBOARDING_SCENARIO`).

## 8. UI/UX Considerations

*   **Responsive Design:** Tailwind CSS is used to ensure the application adapts to various screen sizes.
*   **Visual Feedback:** Loading spinners indicate ongoing processes. Error messages are displayed for issues.
*   **Clear Navigation:** A header provides access to key areas like Profile and Shop. The onboarding process guides new users.
*   **Accessibility:** ARIA attributes are used where appropriate (e.g., `aria-pressed` on the action tag button). Standard HTML elements are used for semantic structure. Further accessibility audit would be beneficial for a production app.
*   **Dark Mode:** The UI uses Tailwind's dark mode variants (`dark:`) to adapt to user's system preferences for a more comfortable viewing experience in low-light environments.
*   **Message Styling:** Different bubble styles and alignments for user, AI, and system messages enhance readability. Special tags (`<action>`, `<visual>`) provide richer AI expression.

## 9. Future Considerations (Potential Enhancements)

*   **Real Backend:** Implement a proper backend for robust authentication, user data storage (instead of Local Storage), and secure API key management.
*   **Advanced AI Memory:** Explore more sophisticated memory systems beyond periodic summarization, possibly using vector databases or more advanced prompting techniques.
*   **More Complex Scenarios:** Introduce scenarios with branching narratives or objectives.
*   **Gamification:** Add achievements, daily quests, or other game-like elements.
*   **Internationalization (i18n):** Support for multiple languages.
*   **Improved Error Handling:** More granular error messages and retry mechanisms for API calls.
*   **Testing:** Implement unit and integration tests.
